/// <reference lib="webworker" />

declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = "aiconnect-v1";
const STATIC_ASSETS = [
  "/",
  "/index.html",
  "/manifest.json",
];

// Add additional assets based on build output
// We'll dynamically load JS and CSS files that are generated by the build process

// Install event handler - cache static assets
self.addEventListener("install", (event: ExtendableEvent) => {
  console.log('[Service Worker] Installing');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[Service Worker] Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        console.log('[Service Worker] Successfully installed');
        return self.skipWaiting();
      })
  );
});

// Activate event handler - clean up old caches
self.addEventListener("activate", (event: ExtendableEvent) => {
  console.log('[Service Worker] Activating');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((cacheName) => cacheName !== CACHE_NAME)
            .map((cacheName) => {
              console.log('[Service Worker] Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            })
        );
      })
      .then(() => {
        console.log('[Service Worker] Successfully activated');
        return self.clients.claim();
      })
  );
});

// Fetch event handler - network first with cache fallback for APIs, cache first for static assets
self.addEventListener("fetch", (event: FetchEvent) => {
  const url = new URL(event.request.url);
  
  // Skip non-GET requests
  if (event.request.method !== "GET") return;
  
  // For API requests, use network first strategy
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirstWithCache(event.request));
    return;
  }
  
  // For static assets, use cache first strategy
  event.respondWith(cacheFirstWithNetwork(event.request));
});

// Network first with cache fallback strategy (for API requests)
async function networkFirstWithCache(request: Request) {
  try {
    // Try network first
    const networkResponse = await fetch(request);
    
    // If successful, clone and cache the response
    if (networkResponse.ok) {
      const clonedResponse = networkResponse.clone();
      caches.open(CACHE_NAME)
        .then(cache => cache.put(request, clonedResponse))
        .catch(err => console.error('[Service Worker] Cache put error:', err));
    }
    
    return networkResponse;
  } catch (error) {
    console.log('[Service Worker] Network request failed, falling back to cache');
    
    // If network fails, try from cache
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // If nothing in cache either, return a simple offline message for API requests
    return new Response(JSON.stringify({ error: 'You are offline' }), {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Cache first with network fallback strategy (for static assets)
async function cacheFirstWithNetwork(request: Request) {
  // Try from cache first
  const cachedResponse = await caches.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // If not in cache, try network
  try {
    const networkResponse = await fetch(request);
    
    // Clone and cache the network response
    if (networkResponse.ok) {
      const clonedResponse = networkResponse.clone();
      caches.open(CACHE_NAME)
        .then(cache => cache.put(request, clonedResponse))
        .catch(err => console.error('[Service Worker] Cache put error:', err));
    }
    
    return networkResponse;
  } catch (error) {
    console.error('[Service Worker] Fetch failed for:', request.url, error);
    
    // For HTML navigation requests, return the offline page
    if (request.headers.get('Accept')?.includes('text/html')) {
      return caches.match('/');
    }
    
    // For other requests, just return an error
    return new Response('Network error occurred', { status: 503 });
  }
}

// Self message handler for cache updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

export {};